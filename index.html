<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KotoChat —Å —Ä–æ–ª—è–º–∏</title>
<style>
  :root {
    --bg: #fff;
    --text: #222;
    --accent: #2ed573;
    --sidebar: #2f3542;
    --header: #57606f;
    --msg-you: #70a1ff;
    --msg-other: #dfe4ea;
    --border: #ccc;
  }
  [data-theme="dark"] {
    --bg: #1e272e;
    --text: #fff;
    --accent: #1dd1a1;
    --sidebar: #2f3542;
    --header: #3742fa;
    --msg-you: #2ed573;
    --msg-other: #57606f;
    --border: #444;
  }
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    display: flex;
    height: 100vh;
  }
  #sidebar {
    width: 280px;
    background: var(--sidebar);
    color: white;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  #sidebar input, #sidebar button {
    padding: 10px;
    border-radius: 6px;
    border: none;
    font-size: 14px;
  }
  #sidebar input {
    width: 100%;
    box-sizing: border-box;
  }
  #sidebar button {
    background: var(--accent);
    color: white;
    cursor: pointer;
  }
  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  #chatHeader {
    background: var(--header);
    color: white;
    padding: 10px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #messages {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    background: var(--bg);
  }
  .msg {
    margin: 5px 0;
    max-width: 70%;
    padding: 8px 14px;
    border-radius: 16px;
    word-wrap: break-word;
  }
  .msg.you {
    background: var(--msg-you);
    color: white;
    align-self: flex-end;
    margin-left: auto;
  }
  .msg.other {
    background: var(--msg-other);
    color: var(--text);
    align-self: flex-start;
    margin-right: auto;
  }
  #inputArea {
    display: none;
    padding: 10px;
    border-top: 1px solid var(--border);
    background: var(--bg);
  }
  #inputArea input[type="text"], #inputArea input[type="password"] {
    flex: 1;
    padding: 10px;
    border-radius: 20px;
    border: 1px solid var(--border);
    font-size: 14px;
  }
  #inputArea button {
    margin-left: 10px;
    padding: 10px 20px;
    border-radius: 20px;
    border: none;
    background: var(--accent);
    color: white;
    cursor: pointer;
  }
  #callArea {
    display: none;
    gap: 10px;
    padding: 10px;
    border-top: 1px solid var(--border);
    background: var(--bg);
  }
  #themeToggle {
    font-size: 13px;
    background: transparent;
    border: 1px solid white;
    color: white;
    padding: 5px 10px;
    border-radius: 8px;
    cursor: pointer;
    align-self: flex-start;
  }
  audio {
    display: none;
  }
  .role-label {
    font-weight: bold;
    margin-left: 10px;
    color: var(--accent);
  }
</style>
</head>
<body data-theme="light">
  <div id="sidebar">
    <h2>KotoChat</h2>
    <button id="themeToggle">üåó –¢–µ–º–∞</button>
    <input id="userIdInput" placeholder="Email" />
    <input id="passwordInput" type="password" placeholder="–ü–∞—Ä–æ–ª—å" />
    <input id="usernameInput" placeholder="–ò–º—è –≤ —á–∞—Ç–µ" />
    <input id="serverInput" placeholder="WebSocket URL" />
    <button id="loginBtn">–í–æ–π—Ç–∏</button>
    <div id="status"></div>
  </div>
  <div id="main">
    <div id="chatHeader">–ù–µ –≤ —á–∞—Ç–µ</div>
    <div id="messages"></div>
    <div id="inputArea">
      <input id="messageInput" type="text" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." />
      <button id="sendBtn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      <span class="role-label" id="roleLabel"></span>
    </div>
    <div id="callArea">
      <button id="callBtn">üìû –ü–æ–∑–≤–æ–Ω–∏—Ç—å</button>
      <button id="hangupBtn" disabled>–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
      <audio id="localAudio" autoplay muted></audio>
      <audio id="remoteAudio" autoplay></audio>
    </div>
  </div>

<script>
(() => {
  const userIdInput = document.getElementById('userIdInput');
  const passwordInput = document.getElementById('passwordInput');
  const usernameInput = document.getElementById('usernameInput');
  const serverInput = document.getElementById('serverInput');
  const loginBtn = document.getElementById('loginBtn');
  const status = document.getElementById('status');
  const messagesDiv = document.getElementById('messages');
  const chatHeader = document.getElementById('chatHeader');
  const inputArea = document.getElementById('inputArea');
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const callArea = document.getElementById('callArea');
  const callBtn = document.getElementById('callBtn');
  const hangupBtn = document.getElementById('hangupBtn');
  const localAudio = document.getElementById('localAudio');
  const remoteAudio = document.getElementById('remoteAudio');
  const themeToggle = document.getElementById('themeToggle');
  const roleLabel = document.getElementById('roleLabel');
  const body = document.body;

  let ws;
  let username = '';
  let userId = '';
  let password = '';
  let serverUrl = '';
  let role = '–ì–æ—Å—Ç—å';
  let connected = false;
  let localStream, peerConnection;
  const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

  function saveCookie(key, value) {
    document.cookie = `${key}=${encodeURIComponent(value)}; path=/; max-age=31536000`;
  }
  function getCookie(key) {
    const match = document.cookie.match(new RegExp('(^| )' + key + '=([^;]+)'));
    return match ? decodeURIComponent(match[2]) : '';
  }

  function initTheme() {
    const saved = getCookie('theme') || 'light';
    body.dataset.theme = saved;
  }
  themeToggle.onclick = () => {
    const newTheme = body.dataset.theme === 'dark' ? 'light' : 'dark';
    body.dataset.theme = newTheme;
    saveCookie('theme', newTheme);
  };

  function showStatus(text) {
    status.textContent = text;
  }

  function addMessage(sender, senderRole, text, isYou) {
    const div = document.createElement('div');
    div.className = 'msg ' + (isYou ? 'you' : 'other');

    let label = '';
    if(senderRole && senderRole !== '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å' && senderRole !== '–ì–æ—Å—Ç—å') {
      label = `[${senderRole}] `;
    }
    div.textContent = label + sender + ': ' + text;
    messagesDiv.appendChild(div);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  function connectWS() {
    ws = new WebSocket(serverUrl.replace(/^http/, 'ws'));
    ws.onopen = () => {
      connected = true;
      showStatus('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ');
      ws.send(JSON.stringify({ type: 'join', username, userId, password }));
      chatHeader.textContent = `–ß–∞—Ç (—Ä–æ–ª—å: ${role})`;
      inputArea.style.display = (role === '–ì–æ—Å—Ç—å') ? 'none' : 'flex';
      callArea.style.display = (role === '–ì–æ—Å—Ç—å') ? 'none' : 'flex';
      roleLabel.textContent = `–†–æ–ª—å: ${role}`;
    };
    ws.onclose = () => {
      connected = false;
      showStatus('‚ùå –û—Ç–∫–ª—é—á–µ–Ω–æ');
      chatHeader.textContent = '–ù–µ –≤ —á–∞—Ç–µ';
      inputArea.style.display = 'none';
      callArea.style.display = 'none';
      roleLabel.textContent = '';
    };
    ws.onerror = () => showStatus('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
    ws.onmessage = async (e) => {
      const data = JSON.parse(e.data);
      switch(data.type) {
        case 'message':
          addMessage(data.username, data.role, data.text, data.username === username);
          break;
        case 'notification':
          addMessage('–°–∏—Å—Ç–µ–º–∞', '', data.text, false);
          break;
        case 'signal':
          await handleSignal(data);
          break;
        case 'error':
          alert(data.text);
          ws.close();
          break;
        case 'role-assigned':
          role = data.role;
          chatHeader.textContent = `–ß–∞—Ç (—Ä–æ–ª—å: ${role})`;
          roleLabel.textContent = `–†–æ–ª—å: ${role}`;
          inputArea.style.display = (role === '–ì–æ—Å—Ç—å') ? 'none' : 'flex';
          callArea.style.display = (role === '–ì–æ—Å—Ç—å') ? 'none' : 'flex';
          break;
      }
    };
  }

  loginBtn.onclick = () => {
    userId = userIdInput.value.trim();
    password = passwordInput.value;
    username = usernameInput.value.trim();
    serverUrl = serverInput.value.trim();
    if(!userId || !password || !username || !serverUrl) {
      alert('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è');
      return;
    }
    saveCookie('userId', userId);
    saveCookie('password', password);
    saveCookie('username', username);
    saveCookie('serverUrl', serverUrl);

    connectWS();
  };

  sendBtn.onclick = () => {
    const text = messageInput.value.trim();
    if(text && connected) {
      ws.send(JSON.stringify({ type: 'message', text }));
      addMessage(username, role, text, true);
      messageInput.value = '';
    }
  };
  messageInput.onkeyup = e => { if(e.key === 'Enter') sendBtn.click(); };

  async function startCall() {
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    localAudio.srcObject = localStream;
    peerConnection = new RTCPeerConnection(config);
    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

    peerConnection.onicecandidate = e => {
      if (e.candidate) {
        ws.send(JSON.stringify({ type: 'signal', signalData: { candidate: e.candidate } }));
      }
    };
    peerConnection.ontrack = e => {
      remoteAudio.srcObject = e.streams[0];
    };

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    ws.send(JSON.stringify({ type: 'signal', signalData: { sdp: peerConnection.localDescription } }));

    hangupBtn.disabled = false;
  }

  async function handleSignal(data) {
    if (!peerConnection) {
      peerConnection = new RTCPeerConnection(config);
      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          ws.send(JSON.stringify({ type: 'signal', signalData: { candidate: e.candidate } }));
        }
      };
      peerConnection.ontrack = e => {
        remoteAudio.srcObject = e.streams[0];
      };
    }
    const s = data.signalData;
    if (s.sdp) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(s.sdp));
      if (s.sdp.type === 'offer') {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        localAudio.srcObject = localStream;
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        ws.send(JSON.stringify({ type: 'signal', signalData: { sdp: peerConnection.localDescription } }));
      }
    } else if (s.candidate) {
      await peerConnection.addIceCandidate(new RTCIceCandidate(s.candidate));
    }
  }

  function hangupCall() {
    if (peerConnection) peerConnection.close();
    peerConnection = null;
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    localAudio.srcObject = null;
   
